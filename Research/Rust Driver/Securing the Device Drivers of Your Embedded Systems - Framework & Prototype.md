tags: #rust #linux

"Securing the Device Drivers of Your Embedded Systems: Framework and Prototype"
Li, Z. Wang, J. Sun, M and Lui, C.S. J. 
2019
Canterbury, United Kingdom. ACM, New York, NY, USA, 10 pages. https:
//doi.org/10.1145/3339252.3340506
Proceedings of the 14th International Conference on Availabil-
ity, Reliability and Security (ARES 2019) (ARES ’19), August 26–29, 2019


## Abstract
+ Proprietary device drivers for embedded systems typically lack quality due to little code auditing
+ New solution to improve reliability and safety of drivers without changing the kernel; Rewriting drivers in Rust (focused on third party developers)
	+ Can help developers detect security issues at compile time (language model)
+ Developed framework to help in quickly building Rust drivers
+ Made use of security features in Rust to create more infrastructure for developers, so its  easier for them to utilise kernel memory allocation & concurrency management, this also solves common bugs
+ Tested on Raspberry Pi 3
+ Evaluation shows drivers generated by this framework have acceptable executable size for official/common embeded systems, runtime overhead is insignificant

## Introduction
+ Definition (and common uses) of Operating Systems: "... control the hardware connected to computers, and provide an universal well-defined interface for userspace applications to interact with different devices"
+ "Unfortunately, device drivers have become one of the most sgnificant source of complexity and vulnerability for computing systems."
	+ Drivers account for more than 60% of Linux kernel codebase
	+ A recent study shows driver code is the most vulnerable within the kernel (see docs in `Documents/Linux Faults and Issues`)
	+ Issues exacerbated by monolithic architecture of the Linux kernel which allows drivers to run with kernel permission and effectively do whatever they wish
+ This situation is even worse for 3rd party devs due to little scrutiny and general low quality of products
	+ 2016, Google reported around 85% of Android kernel bugs occurred in vendor drivers
	+ Various projects were proposed to solve the issue such as hardware, software & language based isolation, micro-kernel architecture, user-space device drivers.
	+ Most of these solutions **indeed** protect drivers against common exploits but they also need to modify the kernel itself or should have support from extra hardware
	+ Some methods also have unacceptable overheads
+ Idea of using Rust
	+ leverage compilers powerful type system, prevent developers from making mistakes that then become attack vectors for hackers
	+ Most security checks are performed at compile time so several errors are detected before the driver is even deployed
	+ The method produces insignificant overhead and there is no requirement of modifying the kernel
+ ##### Rust (programming language)
	+ strongly typed
	+ focus on memory safety, concurrency and performance
	+ enforces safety guarantees at compile time which generates little runtime overhead (other langs like Java/C# need to garbage collect at runtime)
	+ designed for safe system-level programming
	+ Ownership system which avoids bugs like use-after-free
	+ Borrow checker tracks references to ensure they're always valid, clears dangling ptrs and other mem corruptions
	+ No garbage collection for mem mgmt, records lifetime of allocation(s) and statically determines when to deallocate resources
	+ Its possible for Rust to perform within the same range as C/C++

## Background
### Linux drivers
Drivers are an important component to interface between OS & Hardware

Responsibilities
1. Config/Manage 1 (or more) devices
2. Convert requests from kernel into requests to hardware
3. Deliver results from hardware to kernel

Linux is kernel is monolithic but built in a way that it can still extend functions at runtime via kernel modules. (kernel mod is an obj file linked w/ kernel when inserted).

3rd party vendors use modules to distribute their drivers rather than merging source code to the mainline kernel.

These kernel modules introduce several security threats.

Linux kernel has 3 classes of driver types
+ Char devices - byte-stream/file
+ Block devices - random accesses
+ Network devices - work with streams of packets

![[Figure 1 LDD architecture Li et al.png]]

Communicate w/ hardware so drivers only need to work with a system call interface i.e. they all use a unified kernel interface so - to the user - there are no differences

[Callback](https://en.wikipedia.org/wiki/Callback_(computer_programming)) - reference to executable code passed as an argument to another piece of code. That code is expected to call back (or execute ) the callback function as part of its job. It might be immediate (synchronous callback) or happen at a later time (asynchronous callback). Several implementations; subroutines, lambda expressions, blocks or function pointers

Writing a driver involves creating many 'callback functions' for the target device and registering them to the kernel. When the kernel needs to make use of the device, it will use the relevant callback functions. Devs also use various functions and data structures that are defined by the kernel, building drivers on top of other modules or subsystems.

Writing a safe driver is not easy. The monolithic architecture means that the kernel itself and drivers run in the same address space and privilege level. This suggests that drivers can't be stopped from changing critical kernel memory or calling the wrong kernel functions which could lead to a kernel panic. 

Monolothic is more efficient than Micro-kernels but leads to a broader vulnerabilities. Users are forced to trust al drivers even 3rd party vendors. Thus, any driver bug could lead to serious vulnerability which can then further compromise the rest of the system.

Typical driver bugs (attributed to unsafe C):
+ Incorrect boundary checks
+ Null pointer dereference
+ Info leakage
+ Use after free

### Rust
integrates practical experience and research outcomes from C/C++ and ML/Haskell from last several decades

Unique features:

#### Ownership System
+ guarantee mem sagety w/o garbage collection
+ derived from 'linear logic' and 'linear types' so all values must be used exactly once which doesn't need reference counting or garbage collection as linear resources won't be duplicated/discarded
+ Allows safe parallel computation as shared resources don't exist
+ Linear type sys is too constrained for practical use so Rust uses ownership which is more relaxed
+ Each value has a unique owner which is destroyed when owner goes out of scope 
+ Ownership can be transferred between variables where it can't be accessed from the original variable binding
+ References are allowed that temporarily borrow a val w/o invalidating the original binding
+ References are restricted to prevent dangling pointer bugs 

Ownership system eleminates aliasing and ensures every reference is valid, preventing several memory corruption bugs like double free and use-after-free. Compiler also auto handles deallocations without garbage collection plus race conditions are avoided as the mutable reference is unique so its impossible to have more than one thread accessing the same variable.

#### Traits 
+ set of methods that a type *must* implement
+ defined an interface for types, shared behaviours in an abstract way
+ not the same as inheritance
+ defines a group of method signatures to depict behaviours required to fulfill a purpose
+ Using a trait means the programmer should provide all definitions of these methods
+ Enables generic programming which also allows the compiler to carry out type checking

Foreign Function Interface (FFI)


## Framework design, implementation etc (amalgamation of sections 3 and 4)
Framework for writing efficient and safe drivers with Rust.
Using Rusts compiler & type system to write safe kernel modules.

----------------------------------
Architecture is as follows.
![[Figure 2 Rust driver framework Li et al.png]]

+ Several rust source files implement useful infrastructures (kernel mem allocator) and provide API for Rust dev driver development. API can be used my importing framework library in projects.
+ JSON spec file creates bare-metal target for Rust compiler.
+ Some of Rusts own libs must be recompiled for kernle use.
+ Kernel functions & data structs re-exported using `bindgen` 
+ Rust compiler compiles framework and dev libs, creating an object file.
+ Build system takes over linking where the object file is linked as a kernel module.

Framework seen as middleware between devs and kernel. The system solves the following;
+ Build system gets Rust compiler to generate bare-metal code & recompiles necessary libs for kernel space
+ Bindgen transforms Linux kernels C interface into Rust FFI, making the necessary C code available in Rust.
+ Kbuild integrated for building kernel modules.
-----------------------
Framework models device driver types into trairs which then enforces the interface that each driver of a certain type needs to implement.

Developers should define own struct for driver and implement the related trait into their struct.

With this design pattern, all drivers share a unified interface for easy management within the framework. This is a much more elegant interface for driver implementation and reduces boilerplate code such as driver registration and unregistration. (WHICH DEMONSTRATES EXACTLY WHAT I DISCUSSED IN THE MODERN LANGUAGES SECTION OF MY INITIAL RESEARCH PAPER!!!!!)

Driver typically consists of 2 types of code;
1. Device logic implented within driver itself (should be written in pure Rust)
2. Interactions between driver and kernel (provided by framework via FFI bindings)
-----
For the sake of following Rust conventions and providing kernel programming tools that are more useful, parts of the Rust STDLIB are reimplemented to fit into the Linux kernel.

Mem allocator is based on the Rust Global allocator. Developers are able to customise the default memory allocator and redirect all memory alloc requests. This will allow `core` Rust types such as Box and Vex to continue to function within Kernel space. Framework also implements `Mutex` and `Spinlock` to further imitate the Rust stdlib.

----
Build system mixes Rust and Linux kernel. 

Monolithic design of Linux kernel means kernel drivers can't access user space libraries or carry out forbidden operations (such as floating point operations). So the default target of Rust compiler must be changed to generate statically linked and OS-independant machine code w/o float point instructions. To properly leverage existing kernel data structs and functions, kernel headers need to be converted into Rust bindings. (This is fully automated through scripts and makefiles)

Rust compiler is enhanced to generate code that runs directly on hardware, w/o relying on stdlib. Done by adding a new target to Rust compiler. New targets are supported by using JSON spec files that describe the properties of a compilation target (i.e. architecture, OS and default linker). The writers created a custom target which was further modified to match needs such as disabling dynamic linking and use of floating point hardware. 

Pre-compiled libraries need to be recompiled for use with the new target, the libraries provide core Rust features and other useful additionss. 

Kernel headers can't be directly used by Rust so the framework re-exports header symbols via FFI bindings. These will then work in Rust via external C functions . These APIs are automatically generated for practical reasons and to tailor for changes within different kernel versions.

----
Boilerplate code can summarised into a unified interface used for all drivers. 

Below is a code snippet of a char driver implemented as a trait. Every char device must implement an `init()` which takes a string name and `cleanup()` which closes out the driver.

![[CharDriverTrait Li et al.png]]

The use of generic programming means the framework can easily manage different drivers as they all share the same interface. This reduces boilerplate code.

Memory allocation and de-allocation is essentially automatic/handled by the compiler. The writers have implemented their own memory allocator to which all memory requests are re-directed. So when creating a data structure, the programmer isn't reponsible for allocating and later deallocating. "... developers are liberated from delicate and error-prone kernel memory management."

`Mutex` and `Spinlock` are used to support synchronisation which has several benefits;
+ Devs can't access shared data unless `lock()` is specifically invoked
+ Which then prevents cases where devs forget to lock data before use
+ Rust ownership system will also help in releasing locks that are no longer in use or necessary
+ Improper use of this leads to a compilation error

## Common Bugs in Device Drivers
Categorised into 3 groups

##### 1. Language-specifc security issues
Several security issues can be accredited to the use of unsafe languages such as C. Using a safe language can very easily solve these issues.

<u> Names of issues (alongside CVE issues and loose examples) </u>
+ Array-based buffer overflow: CVE-2017-1000363. boundary of array not checked
+ Using unsafe functions: CVE-2010-1084. ex: `gets(), strcpy(), sprintf()`
+ Uninitialised data: CVE-2010-3876. Leaking kernel space data to user space
+ Incorrect kernel memory management: CVE-2018-8087. `kmalloc(), kfree()`
	+ (can also lead to null-ptr deref, mem leakage, double free, user after free)

#### 2. General security issues
Inevitable but Rust can give some help in mitigating issues

+ Integer overflow: math result doesn't fit into fixed-size integer.
+ Concurrency: SMP splitting kernel code to different CPUs. Code can lose CPU at ANY time. Interrupts are sync. (Rust isn't perfect for solving this but type checking helps)

#### 3. Logic errors
Developers are responsible for minimising and handling logic errors during development

+ Deadlock: Group of locks are waiting for each other, none are able to proceed. Happens due to incorrect concurrency management. Rust can't prevent deadlocks (it doesn't consider them for performance) so devs must handle these
+ Error handling: Most errors can be dealth with w/o a kernel panic if they are handled properly. 
	+ "programers tend to focus on functionalities instead of carefully considering all possible causes of errors"
	+ Missing error handling may not be realised until the product is shipped
	+ "programmers usually use inconsistent and implicit placeholders as return values" (0 = success, -1 = failure) (Result enum in Rust can solve this)

	C's method of error handling is 'clumsy and error-prone' 
	Programmers have a common problem of forgetting to check the return value which is then a failure to handle the error


