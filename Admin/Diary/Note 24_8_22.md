## 24/8/22 -- Discussing current findings with regards to driver differences across OS vendors.
(12pm)
Today I'm going to continue the line of research regarding differences between device drivers in 
various Operating Systems. I think the main focus will be between Microsoft Windows, Apple OS' and Linux. 

I've continued to find that Linux documentation is dated almost 2 decades ago, the range is between 2002 and 2014. I think Microsoft basically uprooted their driver documentation because all of their articles are dated within the last couple of years though this could just be a fresh lick of paint. Apple hasn't dated their articles but I must assume it is somewhat recent as several changes have been discussed related to silicone and M1 chips [which began releasing in 2020](https://support.apple.com/en-gb/HT211814). 

Between all 3, I find Apple to be the most interesting. They have decided to split device drivers into 3 specific extension types each with a very specific/set use-case (more information can be found in previous diary entry and within the research folder). This is all in the name of [improving "system stability and makes it easier to develop, debug and install your code."](https://developer.apple.com/documentation/kernel/implementing_drivers_system_extensions_and_kexts) 

There are certainly differences between how drivers are written/developed with regards to Linux  and Windows however they are functionally similar. Both run in Kernel mode where all code can see each other. I like to refer to this Kernel mode as 'The Wild West' as it is very easy for things to go wrong. 

An interesting note about Windows development is that drivers are tested across 2 machines. It works via a remote connection in Visual Studio with a host and target machine. The host machine holds the code etc and basically facilitates the testing session. The target physically runs the driver. At the moment, I think this is a very useful and efficient way of testing drivers, while the target can still crash, the problem of waiting for the machine to recover before being able to re-write code is null and void. I do, however, think there will be some kind of overhead somewhere. 

I think today will mostly concern Linux as I'd like to build up some useful notes in the same way that I have for Windows and Apple. I'd also like to find a decent systems programming project/tutorial/resource for Rust because I want to get my hands dirty, I feel that my projects so far have been very basic and somewhat small in scope. 